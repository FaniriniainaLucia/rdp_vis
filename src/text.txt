<div className="container">
  <div className="left-panel" style={{ 
    height: '100vh', 
    overflow: 'auto',
    display: 'flex',
    flexDirection: 'column'
  }}>
    <h3>Visualisation du Réseau</h3>
    <div 
      className="petri-network"
      style={{ 
        position: 'relative', 
        cursor: draggedElement ? 'grabbing' : 'default',
        flex: 1,
        minHeight: '600px'
      }}
      onMouseMove={(e) => {
        if (!draggedElement) return;
        
        const rect = e.currentTarget.getBoundingClientRect();
        const newX = e.clientX - rect.left - dragOffset.x;
        const newY = e.clientY - rect.top - dragOffset.y;
        
        if (draggedElement.type === 'place') {
          setPlaces(prev => ({
            ...prev,
            [draggedElement.id]: {
              ...prev[draggedElement.id],
              x: Math.max(0, Math.min(newX, rect.width - 80)),
              y: Math.max(0, Math.min(newY, rect.height - 50))
            }
          }));
        } else {
          transitions[draggedElement.id].x = Math.max(0, Math.min(newX, rect.width - 80));
          transitions[draggedElement.id].y = Math.max(0, Math.min(newY, rect.height - 30));
        }
      }}
      onMouseUp={() => {
        setDraggedElement(null);
      }}
      onMouseLeave={() => {
        setDraggedElement(null);
      }}
    >
      <svg width="100%" height="100%" className="network-svg">
        {/* Rendu des arcs en premier (arrière-plan) */}
        {arcs.map((arc, index) => (
          <Arc key={index} from={arc.from} to={arc.to} />
        ))}
      </svg>
      
      {/* Rendu des places */}
      {Object.values(places).map(place => (
        <Place key={place.id} place={place} />
      ))}
      
      {/* Rendu des transitions */}
      {Object.values(transitions).map(transition => (
        <Transition key={transition.id} transition={transition} />
      ))}
    </div>
  </div>
  
  <div className="right-panel">
    {/* Le reste du contenu reste identique */}